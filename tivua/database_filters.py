#   Tivua -- Shared research blog
#   Copyright (C) 2019  Andreas Stöckel
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU Affero General Public License as
#   published by the Free Software Foundation, either version 3 of the
#   License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU Affero General Public License for more details.
#
#   You should have received a copy of the GNU Affero General Public License
#   along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
@file database_filters.py

Defines the "Filter" objects. Filters are used for selecting a subset of the
available posts. Filters can be arranged into a tree structure using operators
and compiled into a corresponding SQL query.

@author Andreas Stöckel
"""

################################################################################
# PUBLIC INTERFACE                                                             #
################################################################################

DEFAULT_JOINS = {
    "posts": "pid",
    "keywords": "pid",
    "fulltext": "rowid"
}

DEFAULT_SELECT_FROM = "posts"

class FilterSQL:
    """
    Class used to represent a SQL query generated by a filter tree. Each filter
    contributes a predicate (i.e., a SQL statement evaluating to true or false)
    that operates on a given table. Furthermore, each predicate formula may
    refer to a number of user-defined parameters.
    """

    def __init__(self, select_from, joins, tables=None, sql=None, params=None):
        """
        Creates a new FilterSQL object with the given "where" and "join"
        descriptors.

        @param select_from is the main table we're selecting elements from.
        @param tables a map from a set of table aliases used in the predicates
               onto the actual underlying table.
        @param sql is the SQL query underlying the filter operation.
        @param params is a tuple of parameters that have to be inserted into the
               SQL query.
        """
        self.select_from = (DEFAULT_SELECT_FROM
                if select_from is None else select_from)
        self.joins = DEFAULT_JOINS if joins is None else joins
        self.tables = dict() if tables is None else tables
        self.sql = str() if sql is None else sql
        self.params = tuple() if params is None else params

    @staticmethod
    def combine(select_from, joins, op, a=None, b=None, is_unary=False):
        """
        Applies either a unary operation or a binary operation to the one/two
        SQL queries.
        """

        def _make_table_aliases(alias):
            p = alias.split("#") if "#" in alias else [alias, ""]
            return p[0] + "#" + p[1] + "a", p[0] + "#" + "b"

        def _unary_op(t):
            if is_unary:
                return "({} {})".format(op, t)
            else:
                return t # No-op

        def _op(t1, t2):
            if t1 and t2:
                return "({} {} {})".format(t1, op, t2)
            elif t1:
                return _unary_op(t1)
            elif t2:
                return _unary_op(t2)
            else:
                return ""

        # Make sure both a and b are proper FilterSQL objects
        a = FilterSQL(select_from, joins) if a is None else a
        b = FilterSQL(select_from, joins) if b is None else b

        # Special case: If we're using NOT or OR and mix different tables, we
        # must use sub-queries
        if op in ("OR", "NOT"):
            tables_combined = set(a.tables.values()) | set(b.tables.values())
            if ((len(tables_combined) > 1) or
                (not select_from in tables_combined)):
                # Emit the SELECT statement for the sub expressions
                sql_a, sql_b, params_a, params_b = "", "", tuple(), tuple()
                if a.sql:
                    sql_a, params_a, _ = a.emit([joins[select_from]])
                    sql_a = "($select_from.{} IN ({}))".format(
                        joins[select_from], sql_a)
                if b.sql:
                    sql_b, params_b, _ = b.emit([joins[select_from]])
                    sql_b = "($select_from.{} IN ({}))".format(
                        joins[select_from], sql_b)

                return FilterSQL(
                    select_from=select_from,
                    joins=joins,
                    tables={"$select_from": select_from},
                    sql=_op(sql_a, sql_b),
                    params=params_a + params_b)

        # Make sure there are no collisions in the table aliases from the "a"
        # and "b" branches
        sql_a = a.sql
        sql_b = b.sql
        tables = {}
        for alias in set(a.tables.keys()) | set(b.tables.keys()):
            if (alias in a.tables) and (alias in b.tables):
                alias_a, alias_b = _make_table_aliases(alias)

                sql_a = sql_a.replace(alias, alias_a)
                sql_b = sql_b.replace(alias, alias_b)

                tables[alias_a] = a.tables[alias]
                tables[alias_b] = b.tables[alias]
            elif alias in a.tables:
                tables[alias] = a.tables[alias]
            elif alias in b.tables:
                tables[alias] = b.tables[alias]

        # Combine the SQL and the parameters
        sql = _op(sql_a, sql_b)
        params = a.params + b.params

        # Return a new FilterSQL instance
        return FilterSQL(
            select_from=select_from,
            joins=joins,
            tables=tables,
            sql=sql,
            params=params)


    def emit(self, select_keys, count=False):
        """
        Compiles the filter query into a SQL statement that operates on the
        given table.
        """

        def _shortest_unique_prefixes(ls):
            """
            Computes the shortest unique prefixes for a list of unique strings.
            """
            N = len(ls)
            ps = list(map(lambda s: s[0], ls))
            while True:
                prefix_count = {}
                for i in range(N):
                    if ps[i] in prefix_count:
                        prefix_count[ps[i]] += 1
                    else:
                        prefix_count[ps[i]] = 1

                if len(prefix_count) == len(ls):
                    return ps

                for i in range(N):
                    if (prefix_count[ps[i]] > 1) and (len(ls[i]) > len(ps[i])):
                        ps[i] += ls[i][len(ps[i])]


        def _generate_table_aliases(tables):
            """
            Turns the table alias list into a nice table alias list.
            """
            # First, generate a multiset mapping from tables onto aliases
            aliases = dict()
            for alias, table in tables.items():
                if not table in aliases:
                    aliases[table] = set()
                aliases[table].add(alias)

            # For each table, generate a the shortest common prefix with other
            # tables
            names = list(aliases.keys())
            short_names = _shortest_unique_prefixes(names)

            # Create a new map from alias onto table, but this time with nicer
            # aliases -- also create a list of substitutions
            tables_new, tables_subs = dict(), dict()
            for i, table in enumerate(names):
                aliases_sorted = list(sorted(aliases[table]))
                if len(aliases_sorted) == 1:
                    old, new = aliases_sorted[0], short_names[i]
                    tables_new[new] = table
                    tables_subs[old] = new
                else:
                    for j in range(len(aliases_sorted)):
                        old = aliases_sorted[j]
                        if table == self.select_from:
                            # We do not need joins on the table we're selecting
                            # from, so collapse the aliases refering to this
                            # table into a single one
                            new = short_names[i]
                        else:
                            new = short_names[i] + str(j + 1)
                        tables_new[new] = table
                        tables_subs[old] = new
            return tables_new, tables_subs

        # Generate short table aliases and substitute them into the SQL query
        tables = self.tables.copy()
        tables["$0"] = self.select_from
        tables, tables_subs = _generate_table_aliases(tables)
        sql_suffix = self.sql
        for src, tar in tables_subs.items():
            sql_suffix = sql_suffix.replace(src, tar)

        # Create the rest of the SQL query
        select_from_alias = tables_subs["$0"]
        if count:
            sql_prefix = "SELECT COUNT() FROM {} AS {}".format(
                self.select_from, select_from_alias)
        else:
            sql_prefix = "SELECT {} FROM {} AS {}".format(", ".join(
                map(lambda s: "{}.{}".format(select_from_alias, s), select_keys)),
                self.select_from, select_from_alias)

        # Generate the necessary JOINs
        sql_mid = ""
        for alias, table in tables.items():
            if alias == select_from_alias:
                continue
            sql_mid += (" JOIN {tbl_src} AS {src_alias} ON"
                        " ({src_alias}.{src} = {tar_alias}.{tar})").format(
                tbl_src=table,
                src_alias=alias,
                tar_alias=select_from_alias,
                src=self.joins[table],
                tar=self.joins[self.select_from])

        # If there are multiple JOINs on different tables, add a "GROUP BY"
        # statement
        if (not count) and len(set(tables.values())) > 1:
            sql_suffix += " GROUP BY {}.{}".format(select_from_alias,
                                                   self.joins[self.select_from])

        if sql_suffix:
            sql = "{}{} WHERE {}".format(sql_prefix, sql_mid, sql_suffix)
        else:
            sql = "{}{}".format(sql_prefix, sql_mid)

        return sql, self.params, select_from_alias

class Filter:
    """
    Abstract base class of all Filter objects. Defines the interface that has
    to be implemented by all concrete Filter classes.
    """

    def do_simplify(self):
        """
        Actual implication of "simplify"; to be implemented by child classes.
        """
        return self

    def do_compile(self, select_from, joins):
        """
        Actual implication of "compile"; to be implemented by child classes.
        """
        raise NotImplementedError()

    def simplify(self):
        """
        Gives the Filter object the chance to create a new, simplified filter
        tree before compilation.
        """
        return self.do_simplify()

    def compile(self, select_from=None, joins=None):
        """
        The "compile" function returns a FilterSQL object -- the FilterSQL
        object represents the SQL for a set of "where" and "join" operations.
        """
        return self.do_compile(
            DEFAULT_SELECT_FROM if select_from is None else select_from,
            DEFAULT_JOINS if joins is None else joins)

    def __and__(self, other):
        """
        Overrides the bitwise "AND" operator to generate a new logical and
        filter.
        """
        return FilterAnd(self, other)

    def __or__(self, other):
        """
        Overrides the bitwise "OR" operator to generate a new logical or filter.
        """
        return FilterOr(self, other)

    def __invert__(self):
        """
        Overrides the bitwise "NOT" operator to generate a negated logical
        filter.
        """
        return FilterNot(self)

    @staticmethod
    def _deserialize_list(obj):
        if len(obj) == 2 and obj[0] == "!":
            return ~Filter.deserialize(obj[1])
        if len(obj) >= 3 and obj[0] == "&":
            res = Filter.deserialize(obj[1])
            for i in range(2, len(obj)):
                res = res & Filter.deserialize(obj[i])
            return res
        if len(obj) >= 3 and obj[0] == "|":
            res = Filter.deserialize(obj[1])
            for i in range(2, len(obj)):
                res = res | Filter.deserialize(obj[i])
            return res
        if len(obj) == 2 and obj[0] == "#":
            return FilterKeyword(obj[1])
        raise ValueError()

    @staticmethod
    def _deserialize_dict(obj):
        if len(obj) == 1:
            key, value = next(iter(obj.items()))
            if key == "date" and isinstance(value, list):
                return FilterDateInterval(int(value[0]), int(value[1]))
            if key == "user":
                return FilterAuthor(int(value))
        raise ValueError()

    @staticmethod
    def deserialize(obj):
        """
        Deserialises a serialized filter object received from the client into
        the corresponding filter structure.
        """
        if isinstance(obj, list):
            return Filter._deserialize_list(obj)
        if isinstance(obj, dict):
            return Filter._deserialize_dict(obj)
        if isinstance(obj, str):
            return FilterFullText(obj)
        raise ValueError()


class FilterTrue(Filter):
    """
    Special filter selecting everything. This is mostly used inside the tree
    simplification process.
    """

    def do_compile(self, select_from, joins):
        return FilterSQL(select_from, joins)


class FilterFalse(Filter):
    """
    Special filter selecting nothing. This is mostly used as part of the tree
    simplification process.
    """

    def do_compile(self, select_from, joins):
        return FilterSQL(select_from, joins, tables={},
                         sql="FALSE", params=tuple())


class FilterLogical(Filter):
    """
    Generic filter used to combine two existing filters using a logical
    operation.
    """

    def __init__(self, a, b, op):
        """
        Creates a new Filter instance for the two given sub-filters "a" and "b"
        and the specified SQL operation
        """
        self.a, self.b, self.op = a, b, op.upper()

    def do_simplify(self):
        """
        Applies logical simplifications.
        """

        a, b, op = self.a.simplify(), self.b.simplify(), self.op

        # Try to combine FilterFullText instances internally, as the database
        # already supports logial expressions in match statements
        if isinstance(a, FilterFullText) and isinstance(b, FilterFullText):
            return FilterFullText((a.match, op, b.match))

        # Simplifcation of simple True/False expressions:
        if op == "OR":
            if isinstance(a, FilterTrue) or isinstance(b, FilterTrue):
                return FilterTrue()
            if isinstance(a, FilterFalse):
                return b
            if isinstance(b, FilterFalse):
                return a
        if op == "AND":
            if isinstance(a, FilterFalse) or isinstance(b, FilterFalse):
                return FilterFalse()
            if isinstance(a, FilterTrue):
                return b
            if isinstance(b, FilterTrue):
                return a

        # Combination of two different author filters with AND
        if isinstance(a, FilterAuthor) and isinstance(b, FilterAuthor):
            if a.uid != b.uid:
                return FilterFalse()
            else:
                return a

        # Otherwise just return a new instance containing the simplified
        # sub-filters
        return self.__class__(a, b, op)

    def do_compile(self, select_from, joins):
        """
        Compiles the logical operation
        """

        return FilterSQL.combine(
            select_from=select_from,
            joins=joins,
            op=self.op,
            a=self.a.compile(select_from, joins),
            b=self.b.compile(select_from, joins))


class FilterAnd(FilterLogical):
    """
    Filter to combine two existing filters via logical and.
    """

    def __init__(self, a, b, _=None):
        super().__init__(a, b, "AND")


class FilterOr(FilterLogical):
    """
    Filter to combine two existing filters via logical and.
    """

    def __init__(self, a, b, _=None):
        super().__init__(a, b, "OR")


class FilterNot(Filter):
    """
    Generic filter used to combine two existing filters using a logical
    operation.
    """

    def __init__(self, a):
        """
        Creates a new Filter instance logically negating the result of the
        filter a.
        """
        self.a = a

    def do_simplify(self):
        """
        Simplifies filter expressions including "NOT".
        """

        # If there is a double-negation, just return the innermost filter
        a = self.a.simplify()
        if isinstance(a, FilterNot):
            return a.a

        # Evaluation of the True/False filters
        if isinstance(a, FilterTrue):
            return FilterFalse()
        if isinstance(a, FilterFalse):
            return FilterTrue()

        # Flip the min/max of an open FilterDateInterval on negation
        if isinstance(a, FilterDateInterval):
            if (a.min is None) or (a.max is None):
                return FilterDateInterval(min_=a.max, max_=a.min)

        # Otherwise return a new FilterNot instance with the simplified
        # sub-filter
        return FilterNot(self.a)

    def do_compile(self, select_from, joins):
        # Otherwise, just try to negate the statement
        return FilterSQL.combine(
            select_from=select_from,
            joins=joins,
            op="NOT",
            a=self.a.compile(select_from, joins),
            is_unary=True)


class FilterUID(Filter):
    """
    Filter that selects posts by either the CUID (create uid) or the MUID (
    modification uid). This filter is usually not exposed to the user interface;
    users are more interested in "FilterAuthor" instead.
    """

    def __init__(self, uid):
        self.uid = uid

    def do_compile(self, select_from, joins):
        return FilterSQL(
            select_from=select_from,
            joins=joins,
            tables={"$posts": "posts"},
            sql="(($posts.cuid = ?) OR ($posts.muid = ?))",
            params=(self.uid, self.uid),
        )

class FilterAuthor(Filter):
    """
    Filters posts for a specific author UID.
    """

    def __init__(self, uid):
        self.uid = uid

    def do_compile(self, select_from, joins):
        return FilterSQL(
            select_from=select_from,
            joins=joins,
            tables={"$posts": "posts"},
            sql="($posts.author = ?)",
            params=(self.uid,),
        )


class FilterDateInterval(Filter):
    """
    Filters posts by the user-defined date.
    """

    def __init__(self, min_=None, max_=None):
        """
        Creates a new FilterDateInterval instance.

        @param min is the minimum date for which a post is returned. If None,
               there is no limit on the minimum age of the post.
        @param max is the maximum date for which a post is returned. If None,
               the is no limit on the maximum age of the post.
        """
        self.min = min_
        self.max = max_

    def do_simplify(self):
        if (self.min is None) and (self.max is None):
            return FilterTrue()
        return self

    def do_compile(self, select_from, joins):
        # No-op if no minimum and maximum is given
        if (self.min is None) and (self.max is None):
            return FilterSQL(select_from, joins)

        # Otherwise, create the SQL and collect the parameters
        sql_parts, params_parts = [], []
        if not self.min is None:
            sql_parts.append("($posts.date >= ?)")
            params_parts.append(self.min)
        if not self.max is None:
            sql_parts.append("($posts.date <= ?)")
            params_parts.append(self.max)

        # Produce the actual SQL string
        fmt = "({})" if len(sql_parts) > 1 else "{}"
        return FilterSQL(
            select_from=select_from,
            joins=joins,
            tables={"$posts": "posts"},
            sql=fmt.format(" AND ".join(sql_parts)),
            params=tuple(params_parts)
        )

class FilterKeyword(Filter):
    """
    Filters posts for a specific keyword.
    """

    def __init__(self, keyword):
        self.keyword = keyword

    def do_compile(self, select_from, joins):
        return FilterSQL(
            select_from=select_from,
            joins=joins,
            tables={"$keywords": "keywords"},
            sql="($keywords.keyword = ?)",
            params=(self.keyword,),
        )


class FilterFullText(Filter):
    """
    Filters for a full text match of a post's content.
    """

    def __init__(self, match):
        self.match = match

    def do_compile(self, select_from, joins):
        def _compile_match_tree(match):
            if isinstance(match, str):
                return "\"" + match.replace("\"", "").replace("'", "") + "\""
            if isinstance(match, tuple) and len(match) == 3:
                return "({} {} {})".format(
                    _compile_match_tree(match[0]),
                    match[1],
                    _compile_match_tree(match[2]))
            raise ValueError()

        return FilterSQL(
            select_from=select_from,
            joins=joins,
            tables={"$fulltext": "fulltext"},
            sql="($fulltext.content MATCH ?)",
            params=(_compile_match_tree(self.match),),
        )
